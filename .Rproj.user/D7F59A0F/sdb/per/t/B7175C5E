{
    "contents" : "#' Split a path into its components\n#' \n#' \\code{decompose_path} splits a path into the directory name, filename \n#' without extension, and extension. \\code{strip_extension} and \n#' \\code{get_extension} provide shortcuts to the second and third parts\n#' of the filename. \\code{recompose_path} takes the result of \n#' \\code{decompose_path} and returns complete paths.\n#' @param x A character vector of file paths. Defaults to files in the \n#' current directory.\n#' @param ... Not currently used.\n#' @return \\code{decompose_path} returns a character matrix with three \n#' columns named \\code{\"dirname\"}, \\code{\"filename\"} and \\code{\"extension\"}.\n#' \\code{strip_extension} returns a character vector of the second column,\n#' and \\code{get_extension} returns a character vector of the third column.\n#' \\code{recompose_path} returns a character vector of paths.\n#' @examples\n#' x <- c(\n#'   \"somedir/foo.tgz\", \n#'   \"another dir\\\\bar.tar.gz\", \n#'   \"baz\", \n#'   \"quux. quuux.tbz2\", \n#'   \"~/quuuux.tar.xz\",\n#'   \"\", \n#'   \".\",\n#'   \"..\",\n#'   NA_character_\n#' )\n#' (decomposed <- decompose_path(x))\n#' recompose_path(decomposed)\n#' @export\ndecompose_path <- function(x = dir())\n{\n  x <- assertive::coerce_to(x, \"character\")\n  base_x <- basename(x)\n  not_missing <- assertive::is_not_na(base_x)\n  has_an_extension <- !(base_x %in% c(\".\", \"..\")) &\n    stringr::str_detect(base_x, stringr::fixed(\".\"))\n  \n  decomposed_x <- cbind(\n    dirname   = dirname(x), \n    filename  = base_x, \n    extension = ifelse(not_missing, \"\", NA_character_)\n  )\n  if(length(base_x) > 0L)\n  {  \n    rownames(decomposed_x) <- x\n    decomposed_x[not_missing & has_an_extension, 2L:3L] <- stringr::str_match(\n      base_x[not_missing & has_an_extension], \n      \"([][\\\\-^!\\\"#$%&'\\\\(\\\\)+,.;=@_`{}~ [:alnum:]]+?)\\\\.([[:alnum:].]+)\"\n    )[, 2L:3L]\n  }\n  structure(decomposed_x, class = c(\"decomposed_path\", \"matrix\"))\n}\n\n#' Copy the contents of a directory\n#' \n#' Copies the contents of a directory, possibly recursively.\n#' @param source_dir String of directory to copy from.\n#' @param target_dir String of directory to copy to.\n#' @param pattern String regex or \\code{NULL}. A filter for filenames, passed  \n#' to \\code{dir}.\n#' @param overwrite Logical value.  Should existing files be overwritten?\n#' @param recursive Logical value.  Should subdirectories and their contents \n#' be copied?\n#' @note Target directories that don't exist are created, silently (assuming  \n#' write permission).\n#' @return A logical vector of whether or not each file was successfully  \n#' copied is invisibly returned.\n#' @seealso \\code{\\link[base]{basename}}\n#' @examples\n#' \\dontrun{\n#' #Copy subdirs by default\n#' dir_copy(R.home(\"etc\"), file.path(tempdir(), \"etc\"))\n#' #Just copy the top level\n#' dir_copy(R.home(\"etc\"), file.path(tempdir(), \"etc2\"), recursive = FALSE)\n#' #Now copy deeper levels, without overwriting.\n#' dir_copy(R.home(\"etc\"), file.path(tempdir(), \"etc2\"), overwrite = FALSE)\n#' #Cleanup\n#' unlink(file.path(tempdir(), \"etc\"), recursive = TRUE)\n#' unlink(file.path(tempdir(), \"etc2\"), recursive = TRUE)\n#' }\n#' @export\ndir_copy <- function(source_dir, target_dir, pattern = NULL, overwrite = FALSE, recursive = TRUE)\n{\n  #Retrieve all file and directory names\n  filenames <- dir(\n    source_dir,\n    pattern      = pattern, \n    recursive    = recursive, \n    all.files    = TRUE,\n    full.names   = FALSE,\n    include.dirs = TRUE\n  )\n  \n  #Create missing directories, silently.\n  is_directory <- assertive::is_dir(file.path(source_dir, filenames))\n  directories <- c(target_dir, file.path(target_dir, filenames[is_directory]))\n  plyr::tryapply(\n    directories,\n    dir.create,\n    showWarnings = FALSE, \n    recursive    = recursive\n  )\n \n  out_dir <- file.path(target_dir, dirname(filenames[!is_directory]))\n  out_dir <- gsub(\"/\\\\.$\", \"\", out_dir)   \n  \n  if(length(out_dir) == 0) return()\n  ok <- mapply(\n    file.copy,\n    from      = file.path(source_dir, filenames[!is_directory]), \n    to        = out_dir,\n    overwrite = overwrite, \n    recursive = FALSE\n  )\n  if(!all(ok))\n  {\n    warning(\n      \"The files \", \n      toString(sQuote(filenames[!ok])), \n      \" were not copied successfully.\"\n    )\n  }\n  names(ok) <- filenames[!is_directory]\n  invisible(ok)\n}\n\n#' @rdname decompose_path\n#' @export\nget_extension <- function(x = dir())\n{\n  decompose_path(x)[, 3L]\n}\n\n#' @rdname decompose_path\n#' @export\nrecompose_path <- function(x, ...)\n{\n  UseMethod(\"recompose_path\")\n}\n\n#' @rdname decompose_path\n#' @method recompose_path decomposed_path\n#' @export\nrecompose_path.decomposed_path <- function(x, ...)\n{\n  not_missing <- assertive::is_not_na(x[, \"filename\"])\n  has_an_extension <- nzchar(x[not_missing, \"extension\"])\n  path <- rep.int(NA_character_, nrow(x))\n  base_x <- ifelse(\n    has_an_extension,\n    paste(x[not_missing, \"filename\"], x[not_missing, \"extension\"], sep = \".\"),\n    x[not_missing, \"filename\"]\n  )\n  path[not_missing] <- file.path(x[not_missing, \"dirname\"], base_x)\n  path\n}\n\n#' @rdname decompose_path\n#' @export\nstrip_extension <- function(x = dir())\n{\n  decompose_path(x)[, 2L]\n}\n",
    "created" : 1398617868084.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2934828090",
    "id" : "B7175C5E",
    "lastKnownWriteTime" : 1398621671,
    "path" : "D:/workspace/pathological/R/paths.R",
    "project_path" : "R/paths.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}