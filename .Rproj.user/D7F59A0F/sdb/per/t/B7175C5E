{
    "contents" : "#' Split a path into its components\n#' \n#' \\code{decompose_path} splits a path into the directory name, filename \n#' without extension, and extension. \\code{strip_extension} and \n#' \\code{get_extension} provide shortcuts to the second and third parts\n#' of the filename. \\code{recompose_path} takes the result of \n#' \\code{decompose_path} and returns complete paths.\n#' @param x A character vector of file paths. Defaults to files in the \n#' current directory.\n#' @param ... Not currently used.\n#' @return \\code{decompose_path} returns a character matrix with three \n#' columns named \\code{\"dirname\"}, \\code{\"filename\"} and \\code{\"extension\"}.\n#' \\code{strip_extension} returns a character vector of the second column,\n#' and \\code{get_extension} returns a character vector of the third column.\n#' \\code{recompose_path} returns a character vector of paths.\n#' @examples\n#' x <- c(\n#'   \"somedir/foo.tgz\",         # single extension\n#'   \"another dir\\\\bar.tar.gz\", # double extension\n#'   \"baz\",                     # no extension\n#'   \"quux. quuux.tbz2\",        # single ext, dots in filename\n#'   R.home(),                  # a dir\n#'   \"~\",                       # another dir\n#'   \"~/quuuux.tar.xz\",         # a file in a dir\n#'   \"\",                        # empty \n#'   \".\",                       # current dir\n#'   \"..\",                      # parent dir\n#'   NA_character_              # missing\n#' )\n#' (decomposed <- decompose_path(x))\n#' get_extension(x)\n#' strip_extension(x)\n#' strip_extension(x, FALSE)\n#' recompose_path(decomposed)\n#' @export\ndecompose_path <- function(x = dir())\n{\n  if(assertive::is_empty(x))\n  {\n    return(\n      data.frame(\n        dirname = character(), \n        filename = character(), \n        extension = character()\n      )\n    )\n  }\n  original_x <- x <- assertive::coerce_to(x, \"character\")\n  x <- standardize_path(x)\n  not_missing <- assertive::is_not_na(x)\n  is_dir_x <- assertive::is_dir(x)\n  \n  basename_x <- ifelse(\n    not_missing,\n    ifelse(is_dir_x, \"\", basename(x)),\n    NA_character_\n  )\n  has_extension <- stringr::str_detect(basename_x, stringr::fixed(\".\"))\n    \n  # match one or more letters, numbers and allowed punctuation characters\n  # (the filename without extension)\n  # then a single period\n  # then match one of more letters numbers and periods\n  # (the file extension)\n  rx <- \"^([][[:alnum:] `!@#$%^&()_=+{},.;'-]+?)\\\\.([[:alnum:].]+)$\"\n  split_name <- stringr::str_match(\n    basename_x[not_missing & has_extension], \n    rx\n  )\n\n  filename_x <- ifelse(not_missing, basename_x, NA_character_)\n  filename_x[not_missing & has_extension] <- split_name[, 2L]\n  extension_x <- ifelse(not_missing, \"\", NA_character_)\n  extension_x[not_missing & has_extension] <- split_name[, 3L]\n  \n  decomposed_x <- data.frame(\n    dirname   = ifelse(\n      not_missing,\n      ifelse(is_dir_x, x, dirname(x)), \n      NA_character_\n    ),\n    filename  = filename_x, \n    extension = extension_x,\n    row.names = original_x\n  )\n  \n  structure(decomposed_x, class = c(\"decomposed_path\", \"data.frame\"))\n}\n\n#' Copy the contents of a directory\n#' \n#' Copies the contents of a directory, possibly recursively.\n#' @param source_dir String of directory to copy from.\n#' @param target_dir String of directory to copy to.\n#' @param pattern String regex or \\code{NULL}. A filter for filenames, passed  \n#' to \\code{dir}.\n#' @param overwrite Logical value.  Should existing files be overwritten?\n#' @param recursive Logical value.  Should subdirectories and their contents \n#' be copied?\n#' @note Target directories that don't exist are created, silently (assuming  \n#' write permission).\n#' @return A logical vector of whether or not each file was successfully  \n#' copied is invisibly returned.\n#' @seealso \\code{\\link[base]{basename}}\n#' @examples\n#' \\dontrun{\n#' #Copy subdirs by default\n#' dir_copy(R.home(\"etc\"), file.path(tempdir(), \"etc\"))\n#' #Just copy the top level\n#' dir_copy(R.home(\"etc\"), file.path(tempdir(), \"etc2\"), recursive = FALSE)\n#' #Now copy deeper levels, without overwriting.\n#' dir_copy(R.home(\"etc\"), file.path(tempdir(), \"etc2\"), overwrite = FALSE)\n#' #Cleanup\n#' unlink(file.path(tempdir(), \"etc\"), recursive = TRUE)\n#' unlink(file.path(tempdir(), \"etc2\"), recursive = TRUE)\n#' }\n#' @export\ndir_copy <- function(source_dir, target_dir, pattern = NULL, overwrite = FALSE, \n  recursive = TRUE)\n{\n  #Retrieve all file and directory names\n  filenames <- dir(\n    source_dir,\n    pattern      = pattern, \n    recursive    = recursive, \n    all.files    = TRUE,\n    full.names   = FALSE,\n    include.dirs = TRUE\n  )\n  \n  #Create missing directories, silently.\n  is_directory <- assertive::is_dir(file.path(source_dir, filenames))\n  directories <- c(target_dir, file.path(target_dir, filenames[is_directory]))\n  plyr::tryapply(\n    directories,\n    dir.create,\n    showWarnings = FALSE, \n    recursive    = recursive\n  )\n \n  out_dir <- file.path(target_dir, dirname(filenames[!is_directory]))\n  out_dir <- gsub(\"/\\\\.$\", \"\", out_dir)   \n  \n  if(length(out_dir) == 0) return()\n  ok <- mapply(\n    file.copy,\n    from      = file.path(source_dir, filenames[!is_directory]), \n    to        = out_dir,\n    overwrite = overwrite, \n    recursive = FALSE\n  )\n  if(!all(ok))\n  {\n    warning(\n      \"The files \", \n      toString(sQuote(filenames[!ok])), \n      \" were not copied successfully.\"\n    )\n  }\n  names(ok) <- filenames[!is_directory]\n  invisible(ok)\n}\n\n#' @rdname decompose_path\n#' @export\nget_extension <- function(x = dir())\n{\n  decompose_path(x)[, 3L]\n}\n\n#' @rdname decompose_path\n#' @export\nrecompose_path <- function(x, ...)\n{\n  UseMethod(\"recompose_path\")\n}\n\n#' @rdname decompose_path\n#' @method recompose_path decomposed_path\n#' @export\nrecompose_path.decomposed_path <- function(x, ...)\n{\n  not_missing <- assertive::is_not_na(x[, \"filename\"])\n  has_an_extension <- nzchar(x[not_missing, \"extension\"])\n  path <- rep.int(NA_character_, nrow(x))\n  base_x <- ifelse(\n    has_an_extension,\n    paste(x[not_missing, \"filename\"], x[not_missing, \"extension\"], sep = \".\"),\n    x[not_missing, \"filename\"]\n  )\n  path[not_missing] <- file.path(x[not_missing, \"dirname\"], base_x)\n  path\n}\n\n#' Standardize paths\n#' \n#' Standardi[sz]e path names so that they can be more easily compared.\n#' @param x A character vector of paths.\n#' @param sep String separator betwen directory levels in the output.\n#' @return A character vector of paths, pointing to the same locations as the\n#' input, but in a standardized form.\n#' @seealso \\code{\\link[base]{normalizePath}}, \\code{\\link[base]{path.expand}}\n#' @examples\n#' standardize_path(c(\".\", \"..\", \"~\", R.home(), NA))\n#' standardize_path(c(\".\", \"..\", \"~\", R.home(), NA), \"\\\\\")\n#' @export\nstandardize_path <- function(x = dir(), sep = c(\"/\", \"\\\\\"))\n{\n  if(assertive::is_empty(x))\n  {\n    return(character())\n  }\n  sep <- match.arg(sep)\n  ifelse(\n    is.na(x),\n    NA_character_,\n    normalizePath(path.expand(x), sep, FALSE)\n  )\n}\n\n#' @rdname standardize_path\n#' @export\nstandardise_path <- standardize_path\n\n#' @rdname decompose_path\n#' @export\nstrip_extension <- function(x = dir(), include_dir = TRUE)\n{\n  decomposed <- decompose_path(x)\n  if(include_dir) \n  {\n    ifelse(\n      is.na(x),\n      NA_character_,\n      file.path(decomposed[, 1L], decomposed[, 2L])\n    )\n  } else\n  {\n    decomposed[, 2L]\n  }\n}\n",
    "created" : 1398617868084.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3810178332",
    "id" : "B7175C5E",
    "lastKnownWriteTime" : 1399138316,
    "path" : "D:/workspace/pathological/R/paths.R",
    "project_path" : "R/paths.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}